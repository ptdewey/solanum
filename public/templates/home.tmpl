{{define "title"}}Home - Solanum{{end}}

{{define "content"}}
<div class="page-header">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h1>Recent Posts</h1>
        <button id="refreshBtn" class="btn btn-primary" onclick="refreshFeeds()">
            <span id="refreshIcon">‚Üª</span> Refresh Feeds
        </button>
    </div>
    <p id="lastUpdated" class="muted" style="margin-top: 0.5rem;"></p>
</div>

<div class="search-form">
    <input 
        type="text" 
        id="searchInput"
        placeholder="Search posts..." 
        class="input"
        oninput="performSearch()"
    />
    <button id="clearSearchBtn" class="btn btn-secondary" onclick="clearSearch()" style="display: none;">Clear</button>
</div>

<div id="loading" style="text-align: center; padding: 2rem; display: none;">
    <p>Loading feed items...</p>
</div>

<div id="results"></div>

<div id="pagination" class="pagination"></div>

<style>
.page-header {
    margin-bottom: 1.5rem;
}

.search-form {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
}

.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 2rem;
    padding: 1rem;
}

.pagination button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.feed-badge {
    display: inline-block;
    color: var(--moss-500);
    font-size: 0.875rem;
    font-weight: 500;
}

.feed-badge a {
    color: var(--moss-500);
    text-decoration: none;
}

.feed-badge a:hover {
    color: var(--moss-600);
    text-decoration: underline;
}

#refreshBtn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.spinning {
    display: inline-block;
    animation: spin 1s linear infinite;
}

.entry-actions {
    display: flex;
    gap: 0.25rem;
    flex-wrap: wrap;
}

.feed-item.removing {
    opacity: 0.5;
    transition: opacity 0.3s ease-out;
}

@keyframes fadeOut {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(0.95); }
}

.feed-item.fade-out {
    animation: fadeOut 0.3s ease-out forwards;
}
</style>

<script>
let allItems = [];
let filteredItems = [];
let currentPage = 1;
const itemsPerPage = 25;
let searchQuery = '';
{{if .CurrentFeed}}
const filterFeedURL = "{{.CurrentFeed.URL}}";
{{else}}
const filterFeedURL = null;
{{end}}

// Create a mapping from feed URL to feed RKey for linking
const feedURLToRKey = {
{{range .Feeds}}
    "{{.URL}}": "{{.RKey}}",
{{end}}
};

// Load cache on page load
document.addEventListener('DOMContentLoaded', () => {
    loadCache();
});

async function loadCache() {
    const cachedData = localStorage.getItem('feedCacheData');
    const cachedTimestamp = localStorage.getItem('feedCacheTimestamp');
    
    if (cachedData && cachedTimestamp) {
        console.log('Using cached data from localStorage');
        const data = JSON.parse(cachedData);
        allItems = data.items || [];
        updateLastUpdated(parseInt(cachedTimestamp));
        applyFiltersAndRender();
    } else {
        console.log('No localStorage cache, fetching from server');
        // Try to fetch from server
        await fetchCacheFromServer();
    }
}

async function fetchCacheFromServer() {
    const loading = document.getElementById('loading');
    loading.style.display = 'block';
    
    try {
        const response = await fetch('/feeds/cache');
        if (!response.ok) {
            if (response.status === 404) {
                // No cache yet - show empty state
                allItems = [];
                applyFiltersAndRender();
                return;
            }
            throw new Error('Failed to fetch cache');
        }
        
        const data = await response.json();
        
        // Check for blob corruption error
        if (data.error === 'blob_corrupted') {
            console.warn('PDS blob was corrupted, user needs to refresh');
            document.getElementById('results').innerHTML = `
                <div class="empty-state">
                    <p>Your feed cache was corrupted in storage.</p>
                    <p>Click "Refresh Feeds" to recreate it.</p>
                </div>
            `;
            loading.style.display = 'none';
            return;
        }
        
        allItems = data.items || [];
        
        // Save to localStorage
        const timestamp = Date.now();
        localStorage.setItem('feedCacheData', JSON.stringify(data));
        localStorage.setItem('feedCacheTimestamp', timestamp.toString());
        
        updateLastUpdated(timestamp);
        applyFiltersAndRender();
    } catch (error) {
        console.error('Error fetching cache:', error);
        document.getElementById('results').innerHTML = '<div class="empty-state"><p>Failed to load feed items. Try refreshing.</p></div>';
    } finally {
        loading.style.display = 'none';
    }
}

async function refreshFeeds() {
    const btn = document.getElementById('refreshBtn');
    const icon = document.getElementById('refreshIcon');
    
    btn.disabled = true;
    icon.classList.add('spinning');
    
    try {
        const response = await fetch('/feeds/refresh', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error('Failed to refresh feeds');
        }
        
        const data = await response.json();
        allItems = data.items || [];
        
        // Save to localStorage
        const timestamp = Date.now();
        localStorage.setItem('feedCacheData', JSON.stringify(data));
        localStorage.setItem('feedCacheTimestamp', timestamp.toString());
        
        updateLastUpdated(timestamp);
        applyFiltersAndRender();
    } catch (error) {
        console.error('Error refreshing feeds:', error);
        alert('Failed to refresh feeds. Please try again.');
    } finally {
        btn.disabled = false;
        icon.classList.remove('spinning');
    }
}

function updateLastUpdated(timestamp) {
    const now = Date.now();
    const diff = Math.floor((now - timestamp) / 1000); // seconds
    
    let text = 'Last updated: ';
    if (diff < 60) {
        text += 'just now';
    } else if (diff < 3600) {
        const minutes = Math.floor(diff / 60);
        text += `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
    } else if (diff < 86400) {
        const hours = Math.floor(diff / 3600);
        text += `${hours} hour${hours !== 1 ? 's' : ''} ago`;
    } else {
        const days = Math.floor(diff / 86400);
        text += `${days} day${days !== 1 ? 's' : ''} ago`;
    }
    
    document.getElementById('lastUpdated').textContent = text;
}

function performSearch() {
    searchQuery = document.getElementById('searchInput').value.toLowerCase().trim();
    const clearBtn = document.getElementById('clearSearchBtn');
    
    if (searchQuery) {
        clearBtn.style.display = 'block';
    } else {
        clearBtn.style.display = 'none';
    }
    
    currentPage = 1;
    applyFiltersAndRender();
}

function clearSearch() {
    document.getElementById('searchInput').value = '';
    searchQuery = '';
    document.getElementById('clearSearchBtn').style.display = 'none';
    currentPage = 1;
    applyFiltersAndRender();
}

function applyFiltersAndRender() {
    // Filter items based on feed URL (if viewing a single feed)
    let items = allItems;
    if (filterFeedURL) {
        items = items.filter(item => item.feedURL === filterFeedURL);
    }
    
    // Filter items based on search
    if (searchQuery) {
        filteredItems = items.filter(item => {
            return item.title.toLowerCase().includes(searchQuery) ||
                   (item.description && item.description.toLowerCase().includes(searchQuery)) ||
                   (item.author && item.author.toLowerCase().includes(searchQuery)) ||
                   item.feedTitle.toLowerCase().includes(searchQuery);
        });
    } else {
        filteredItems = items;
    }
    
    renderItems();
    renderPagination();
}

function renderItems() {
    const results = document.getElementById('results');
    
    if (filteredItems.length === 0) {
        if (searchQuery) {
            results.innerHTML = '<div class="empty-state"><p>No posts match your search.</p></div>';
        } else if (allItems.length === 0) {
            results.innerHTML = '<div class="empty-state"><p>No posts yet. <a href="/feeds">Add some feeds</a> and click "Refresh Feeds" to get started.</p></div>';
        } else {
            results.innerHTML = '<div class="empty-state"><p>No posts found.</p></div>';
        }
        return;
    }
    
    // Calculate pagination
    const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
    if (currentPage > totalPages) currentPage = totalPages;
    if (currentPage < 1) currentPage = 1;
    
    const startIdx = (currentPage - 1) * itemsPerPage;
    const endIdx = Math.min(startIdx + itemsPerPage, filteredItems.length);
    const pageItems = filteredItems.slice(startIdx, endIdx);
    
    // Render items
    let html = '';
    if (searchQuery) {
        html += `<p class="muted">Found ${filteredItems.length} result${filteredItems.length !== 1 ? 's' : ''} for "${escapeHtml(searchQuery)}"</p>`;
    }
    
    pageItems.forEach(item => {
        const date = new Date(item.published);
        const formattedDate = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        
        // Get feed RKey for linking
        const feedRKey = feedURLToRKey[item.feedURL];
        const feedLink = feedRKey ? `/feeds/${escapeHtml(feedRKey)}/view` : '#';
        
        html += `
        <div class="feed-item" id="entry-${escapeHtml(item.link).replace(/[^a-zA-Z0-9]/g, '_')}">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <span class="feed-badge"><a href="${feedLink}">${escapeHtml(item.feedTitle)}</a></span>
                <div class="entry-actions">
                    <button 
                        class="btn btn-ghost btn-sm"
                        onclick="markAsRead('${escapeJs(item.link)}', '${escapeJs(item.title)}', '${escapeJs(item.description || '')}')"
                        title="Mark as read">
                        ‚úì Read
                    </button>
                    <button 
                        class="btn btn-ghost btn-sm"
                        onclick="saveForLater('${escapeJs(item.link)}', '${escapeJs(item.title)}', '${escapeJs(item.description || '')}')"
                        title="Save for later">
                        üìë Save
                    </button>
                    <button 
                        class="btn btn-danger btn-sm"
                        onclick="removeEntry('${escapeJs(item.link)}')"
                        title="Remove from feed">
                        ‚úï
                    </button>
                </div>
            </div>
            <h3 class="feed-item-title">
                <a href="${escapeHtml(item.link)}" target="_blank">${escapeHtml(item.title)}</a>
            </h3>
            <div class="feed-item-meta">
                ${item.author ? escapeHtml(item.author) + ' &middot; ' : ''}
                ${formattedDate}
            </div>
            ${item.description ? `<p class="feed-item-description">${escapeHtml(item.description)}</p>` : ''}
        </div>
        `;
    });
    
    results.innerHTML = html;
}

function renderPagination() {
    const pagination = document.getElementById('pagination');
    const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
    
    if (totalPages <= 1) {
        pagination.innerHTML = '';
        return;
    }
    
    const hasPrev = currentPage > 1;
    const hasNext = currentPage < totalPages;
    
    let html = '';
    
    if (hasPrev) {
        html += `<button class="btn" onclick="goToPage(${currentPage - 1})">‚Üê Previous</button>`;
    } else {
        html += `<button class="btn" disabled>‚Üê Previous</button>`;
    }
    
    html += `<span>Page ${currentPage} of ${totalPages}</span>`;
    
    if (hasNext) {
        html += `<button class="btn" onclick="goToPage(${currentPage + 1})">Next ‚Üí</button>`;
    } else {
        html += `<button class="btn" disabled>Next ‚Üí</button>`;
    }
    
    pagination.innerHTML = html;
}

function goToPage(page) {
    currentPage = page;
    renderItems();
    renderPagination();
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function escapeJs(text) {
    if (!text) return '';
    return text
        .replace(/\\/g, '\\\\')
        .replace(/'/g, "\\'")
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\t/g, '\\t');
}

async function removeEntry(url) {
    if (!confirm('Remove this entry from your feed?')) {
        return;
    }
    
    const cardId = 'entry-' + url.replace(/[^a-zA-Z0-9]/g, '_');
    const card = document.getElementById(cardId);
    
    if (card) {
        card.classList.add('removing');
    }
    
    try {
        const response = await fetch('/entries/remove', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `url=${encodeURIComponent(url)}`
        });
        
        if (!response.ok) {
            throw new Error('Failed to remove entry');
        }
        
        // Remove from local data
        allItems = allItems.filter(item => item.link !== url);
        
        // Update localStorage
        const cachedData = localStorage.getItem('feedCacheData');
        if (cachedData) {
            const data = JSON.parse(cachedData);
            data.items = data.items.filter(item => item.link !== url);
            localStorage.setItem('feedCacheData', JSON.stringify(data));
        }
        
        // Animate removal and re-render
        if (card) {
            card.classList.add('fade-out');
            setTimeout(() => {
                applyFiltersAndRender();
            }, 300);
        } else {
            applyFiltersAndRender();
        }
    } catch (error) {
        console.error('Error removing entry:', error);
        alert('Failed to remove entry. Please try again.');
        if (card) {
            card.classList.remove('removing');
        }
    }
}

async function markAsRead(url, title, description) {
    const cardId = 'entry-' + url.replace(/[^a-zA-Z0-9]/g, '_');
    const card = document.getElementById(cardId);
    
    if (card) {
        card.classList.add('removing');
    }
    
    try {
        const response = await fetch('/entries/mark-read', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `url=${encodeURIComponent(url)}&title=${encodeURIComponent(title)}&description=${encodeURIComponent(description)}`
        });
        
        if (!response.ok) {
            throw new Error('Failed to mark as read');
        }
        
        // Remove from local data (marked as read entries are filtered out)
        allItems = allItems.filter(item => item.link !== url);
        
        // Update localStorage
        const cachedData = localStorage.getItem('feedCacheData');
        if (cachedData) {
            const data = JSON.parse(cachedData);
            data.items = data.items.filter(item => item.link !== url);
            localStorage.setItem('feedCacheData', JSON.stringify(data));
        }
        
        // Animate removal and re-render
        if (card) {
            card.classList.add('fade-out');
            setTimeout(() => {
                applyFiltersAndRender();
            }, 300);
        } else {
            applyFiltersAndRender();
        }
    } catch (error) {
        console.error('Error marking as read:', error);
        alert('Failed to mark as read. Please try again.');
        if (card) {
            card.classList.remove('removing');
        }
    }
}

async function saveForLater(url, title, description) {
    try {
        const response = await fetch('/reading-list', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `url=${encodeURIComponent(url)}&title=${encodeURIComponent(title)}&description=${encodeURIComponent(description)}`
        });
        
        if (!response.ok) {
            throw new Error('Failed to save for later');
        }
        
        // Show success message
        const cardId = 'entry-' + url.replace(/[^a-zA-Z0-9]/g, '_');
        const card = document.getElementById(cardId);
        if (card) {
            const originalContent = card.style.borderColor;
            card.style.borderColor = 'var(--moss-500)';
            setTimeout(() => {
                card.style.borderColor = originalContent;
            }, 1000);
        }
        
        alert('Saved to reading list!');
    } catch (error) {
        console.error('Error saving for later:', error);
        alert('Failed to save to reading list. Please try again.');
    }
}
</script>
{{end}}
